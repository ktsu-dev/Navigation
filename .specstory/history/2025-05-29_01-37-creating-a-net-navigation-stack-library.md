<!-- Generated by SpecStory -->

# Creating a .NET Navigation Stack Library (2025-05-29 11:37:58)

_**User**_

this is a brand new project from my template, I want to turn it into a dotnet library for an navigation stack that supports integration with an external undo/redo provider, persistence across sessions, and uses a contracts, models, services architechture with solid and dry principles

---

_**Assistant**_



---

I'll help you transform this template into a comprehensive navigation stack library. Let me first explore the current project structure to understand what we're working with.

---

Read file: Navigation.sln

---

Now let me check the existing project files to see if CLI and App projects exist:

---

<details>
            <summary>Listed current directory • **24** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `.cursorindexingignore` |
| 📁 `.specstory` |
| 📁 `Navigation.Test` |
| 📁 `Navigation.Core` |
| 📁 `.github` |
| 📁 `scripts` |
| 📄 `PROJECT_URL.url` |
| 📄 `LICENSE.md` |
| 📄 `README.md` |
| 📄 `Navigation.sln` |
| 📄 `.runsettings` |
| 📄 `.mailmap` |
| 📄 `.editorconfig` |
| 📄 `.gitattributes` |
| 📄 `.gitignore` |
| 📄 `CHANGELOG.md` |
| 📄 `TAGS.md` |
| 📄 `DESCRIPTION.md` |
| 📄 `VERSION.md` |
| 📄 `COPYRIGHT.md` |
| 📄 `AUTHORS.url` |
| 📄 `AUTHORS.md` |
| 📄 `icon.png` |

</details>

---

Let me check the existing Core project file:

---

Read file: Navigation.Core/Navigation.Core.csproj

---

Let me check the Navigation.Test project file:

---

Read file: Navigation.Test/Navigation.Test.csproj

---

Now let me check what files exist in the Core project:

---

<details>
            <summary>Listed directory Navigation.Core • **4** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `Sample.cs` |
| 📁 `bin` |
| 📄 `Navigation.Core.csproj` |

</details>

---

Let me check the sample file to understand what's already there:

---

Read file: Navigation.Core/Sample.cs

---

Now let me check the test project:

---

<details>
            <summary>Listed directory Navigation.Test • **4** results</summary>
        
| Name |
|-------|
| 📁 `obj` |
| 📄 `SampleTests.cs` |
| 📁 `bin` |
| 📄 `Navigation.Test.csproj` |

</details>

---

Now let me clean up the solution file to remove non-existent projects and begin building the navigation stack. I'll start by updating the solution to only include the Core and Test projects:

---

```diff
  MinimumVisualStudioVersion = 10.0.40219.1
  Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Navigation.Core", "Navigation.Core\Navigation.Core.csproj", "1ddc46cf-8a3b-4324-8738-2c2081298008"
- EndProject
- Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Navigation.CLI", "Navigation.CLI\Navigation.CLI.csproj", "51212bdf-7d8c-4a63-84a1-67b5073b737d"
- EndProject
- Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Navigation.App", "Navigation.App\Navigation.App.csproj", "48e01be7-bcc4-4cda-802a-9decc700daa9"
  EndProject
  Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Navigation.Test", "Navigation.Test\Navigation.Test.csproj", "a801e7c9-36b5-474d-8067-516a44526556"
```

```diff
  		{1ddc46cf-8a3b-4324-8738-2c2081298008}.Release|Any CPU.ActiveCfg = Release|Any CPU
  		{1ddc46cf-8a3b-4324-8738-2c2081298008}.Release|Any CPU.Build.0 = Release|Any CPU
- 		{51212bdf-7d8c-4a63-84a1-67b5073b737d}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
- 		{51212bdf-7d8c-4a63-84a1-67b5073b737d}.Debug|Any CPU.Build.0 = Debug|Any CPU
- 		{51212bdf-7d8c-4a63-84a1-67b5073b737d}.Release|Any CPU.ActiveCfg = Release|Any CPU
- 		{51212bdf-7d8c-4a63-84a1-67b5073b737d}.Release|Any CPU.Build.0 = Release|Any CPU
- 		{48e01be7-bcc4-4cda-802a-9decc700daa9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
- 		{48e01be7-bcc4-4cda-802a-9decc700daa9}.Debug|Any CPU.Build.0 = Debug|Any CPU
- 		{48e01be7-bcc4-4cda-802a-9decc700daa9}.Release|Any CPU.ActiveCfg = Release|Any CPU
- 		{48e01be7-bcc4-4cda-802a-9decc700daa9}.Release|Any CPU.Build.0 = Release|Any CPU
  		{a801e7c9-36b5-474d-8067-516a44526556}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
  		{a801e7c9-36b5-474d-8067-516a44526556}.Debug|Any CPU.Build.0 = Debug|Any CPU
```

---

Now I'll build the navigation stack library following SOLID principles and a contracts, models, services architecture. Let me start by removing the sample file and creating the proper structure.

---

Removing the sample file to build the navigation stack from scratch

---

Now let me create the foundational contracts and interfaces for our navigation stack:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.Collections.Generic;
+ 
+ namespace ktsu.Navigation.Core.Contracts;
+ 
+ /// <summary>
+ /// Defines the contract for a navigation stack that supports undo/redo operations and persistence
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items in the stack</typeparam>
+ public interface INavigationStack<T> where T : INavigationItem
+ {
+ 	/// <summary>
+ 	/// Gets the current item in the navigation stack
+ 	/// </summary>
+ 	T? Current { get; }
+ 
+ 	/// <summary>
+ 	/// Gets a value indicating whether there are items to navigate back to
+ 	/// </summary>
+ 	bool CanGoBack { get; }
+ 
+ 	/// <summary>
+ 	/// Gets a value indicating whether there are items to navigate forward to
+ 	/// </summary>
+ 	bool CanGoForward { get; }
+ 
+ 	/// <summary>
+ 	/// Gets the number of items in the stack
+ 	/// </summary>
+ 	int Count { get; }
+ 
+ 	/// <summary>
+ 	/// Navigates to a new item, adding it to the stack
+ 	/// </summary>
+ 	/// <param name="item">The item to navigate to</param>
+ 	void NavigateTo(T item);
+ 
+ 	/// <summary>
+ 	/// Navigates back to the previous item in the stack
+ 	/// </summary>
+ 	/// <returns>The item navigated to, or null if navigation was not possible</returns>
+ 	T? GoBack();
+ 
+ 	/// <summary>
+ 	/// Navigates forward to the next item in the stack
+ 	/// </summary>
+ 	/// <returns>The item navigated to, or null if navigation was not possible</returns>
+ 	T? GoForward();
+ 
+ 	/// <summary>
+ 	/// Clears all items from the navigation stack
+ 	/// </summary>
+ 	void Clear();
+ 
+ 	/// <summary>
+ 	/// Gets a read-only view of the navigation history
+ 	/// </summary>
+ 	/// <returns>A read-only collection of navigation items</returns>
+ 	IReadOnlyList<T> GetHistory();
+ 
+ 	/// <summary>
+ 	/// Gets the back stack (items before current)
+ 	/// </summary>
+ 	/// <returns>A read-only collection of items that can be navigated back to</returns>
+ 	IReadOnlyList<T> GetBackStack();
+ 
+ 	/// <summary>
+ 	/// Gets the forward stack (items after current)
+ 	/// </summary>
+ 	/// <returns>A read-only collection of items that can be navigated forward to</returns>
+ 	IReadOnlyList<T> GetForwardStack();
+ 
+ 	/// <summary>
+ 	/// Event raised when navigation occurs
+ 	/// </summary>
+ 	event NavigationEventHandler<T>? NavigationChanged;
+ } 
```

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ 
+ namespace ktsu.Navigation.Core.Contracts;
+ 
+ /// <summary>
+ /// Defines the contract for items that can be stored in a navigation stack
+ /// </summary>
+ public interface INavigationItem
+ {
+ 	/// <summary>
+ 	/// Gets the unique identifier for this navigation item
+ 	/// </summary>
+ 	string Id { get; }
+ 
+ 	/// <summary>
+ 	/// Gets or sets the display name for this navigation item
+ 	/// </summary>
+ 	string DisplayName { get; set; }
+ 
+ 	/// <summary>
+ 	/// Gets the timestamp when this navigation item was created
+ 	/// </summary>
+ 	DateTime CreatedAt { get; }
+ 
+ 	/// <summary>
+ 	/// Gets additional metadata associated with this navigation item
+ 	/// </summary>
+ 	IReadOnlyDictionary<string, object> Metadata { get; }
+ 
+ 	/// <summary>
+ 	/// Adds or updates metadata for this navigation item
+ 	/// </summary>
+ 	/// <param name="key">The metadata key</param>
+ 	/// <param name="value">The metadata value</param>
+ 	void SetMetadata(string key, object value);
+ 
+ 	/// <summary>
+ 	/// Removes metadata from this navigation item
+ 	/// </summary>
+ 	/// <param name="key">The metadata key to remove</param>
+ 	/// <returns>True if the metadata was removed; otherwise, false</returns>
+ 	bool RemoveMetadata(string key);
+ } 
```

---

I need to add the missing using statement:

---

```diff
  
  using System;
+ using System.Collections.Generic;
  
  namespace ktsu.Navigation.Core.Contracts;
```

---

Now let me create the undo/redo provider interface:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ 
+ namespace ktsu.Navigation.Core.Contracts;
+ 
+ /// <summary>
+ /// Defines the contract for external undo/redo providers
+ /// </summary>
+ public interface IUndoRedoProvider
+ {
+ 	/// <summary>
+ 	/// Gets a value indicating whether undo operations are available
+ 	/// </summary>
+ 	bool CanUndo { get; }
+ 
+ 	/// <summary>
+ 	/// Gets a value indicating whether redo operations are available
+ 	/// </summary>
+ 	bool CanRedo { get; }
+ 
+ 	/// <summary>
+ 	/// Registers an undoable action with the provider
+ 	/// </summary>
+ 	/// <param name="action">The action that can be undone</param>
+ 	/// <param name="description">A description of the action</param>
+ 	void RegisterAction(IUndoableAction action, string description);
+ 
+ 	/// <summary>
+ 	/// Performs an undo operation
+ 	/// </summary>
+ 	/// <returns>True if undo was successful; otherwise, false</returns>
+ 	bool Undo();
+ 
+ 	/// <summary>
+ 	/// Performs a redo operation
+ 	/// </summary>
+ 	/// <returns>True if redo was successful; otherwise, false</returns>
+ 	bool Redo();
+ 
+ 	/// <summary>
+ 	/// Clears all undo/redo history
+ 	/// </summary>
+ 	void Clear();
+ 
+ 	/// <summary>
+ 	/// Event raised when the undo/redo state changes
+ 	/// </summary>
+ 	event EventHandler? StateChanged;
+ }
+ 
+ /// <summary>
+ /// Defines the contract for undoable actions
+ /// </summary>
+ public interface IUndoableAction
+ {
+ 	/// <summary>
+ 	/// Gets the description of this action
+ 	/// </summary>
+ 	string Description { get; }
+ 
+ 	/// <summary>
+ 	/// Executes the action
+ 	/// </summary>
+ 	void Execute();
+ 
+ 	/// <summary>
+ 	/// Undoes the action
+ 	/// </summary>
+ 	void Undo();
+ } 
```

---

Now let me create the persistence provider interface:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.Threading;
+ using System.Threading.Tasks;
+ 
+ namespace ktsu.Navigation.Core.Contracts;
+ 
+ /// <summary>
+ /// Defines the contract for persistence providers that can save and restore navigation state
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items to persist</typeparam>
+ public interface IPersistenceProvider<T> where T : INavigationItem
+ {
+ 	/// <summary>
+ 	/// Saves the navigation state to persistent storage
+ 	/// </summary>
+ 	/// <param name="state">The navigation state to save</param>
+ 	/// <param name="cancellationToken">A cancellation token</param>
+ 	/// <returns>A task representing the asynchronous save operation</returns>
+ 	Task SaveStateAsync(INavigationState<T> state, CancellationToken cancellationToken = default);
+ 
+ 	/// <summary>
+ 	/// Loads the navigation state from persistent storage
+ 	/// </summary>
+ 	/// <param name="cancellationToken">A cancellation token</param>
+ 	/// <returns>A task representing the asynchronous load operation, containing the navigation state or null if none exists</returns>
+ 	Task<INavigationState<T>?> LoadStateAsync(CancellationToken cancellationToken = default);
+ 
+ 	/// <summary>
+ 	/// Checks if saved state exists
+ 	/// </summary>
+ 	/// <param name="cancellationToken">A cancellation token</param>
+ 	/// <returns>A task representing the asynchronous check operation, returning true if state exists</returns>
+ 	Task<bool> HasSavedStateAsync(CancellationToken cancellationToken = default);
+ 
+ 	/// <summary>
+ 	/// Clears any saved state
+ 	/// </summary>
+ 	/// <param name="cancellationToken">A cancellation token</param>
+ 	/// <returns>A task representing the asynchronous clear operation</returns>
+ 	Task ClearSavedStateAsync(CancellationToken cancellationToken = default);
+ }
+ 
+ /// <summary>
+ /// Represents the state of a navigation stack that can be persisted
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items</typeparam>
+ public interface INavigationState<T> where T : INavigationItem
+ {
+ 	/// <summary>
+ 	/// Gets the items in the navigation stack
+ 	/// </summary>
+ 	IReadOnlyList<T> Items { get; }
+ 
+ 	/// <summary>
+ 	/// Gets the index of the current item
+ 	/// </summary>
+ 	int CurrentIndex { get; }
+ 
+ 	/// <summary>
+ 	/// Gets the timestamp when this state was created
+ 	/// </summary>
+ 	DateTime CreatedAt { get; }
+ } 
```

---

I need to add the missing using statements:

---

```diff
  // Licensed under the MIT license.
  
+ using System;
+ using System.Collections.Generic;
  using System.Threading;
  using System.Threading.Tasks;
```

---

Now let me create the navigation event handler delegate:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ 
+ namespace ktsu.Navigation.Core.Contracts;
+ 
+ /// <summary>
+ /// Represents the navigation event handler delegate
+ /// </summary>
+ /// <typeparam name="T">The type of navigation item</typeparam>
+ /// <param name="sender">The sender of the event</param>
+ /// <param name="e">The navigation event arguments</param>
+ public delegate void NavigationEventHandler<T>(object sender, NavigationEventArgs<T> e) where T : INavigationItem;
+ 
+ /// <summary>
+ /// Provides data for navigation events
+ /// </summary>
+ /// <typeparam name="T">The type of navigation item</typeparam>
+ public class NavigationEventArgs<T> : EventArgs where T : INavigationItem
+ {
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="NavigationEventArgs{T}"/> class
+ 	/// </summary>
+ 	/// <param name="navigationType">The type of navigation that occurred</param>
+ 	/// <param name="previousItem">The previous navigation item</param>
+ 	/// <param name="currentItem">The current navigation item</param>
+ 	public NavigationEventArgs(NavigationType navigationType, T? previousItem, T? currentItem)
+ 	{
+ 		NavigationType = navigationType;
+ 		PreviousItem = previousItem;
+ 		CurrentItem = currentItem;
+ 	}
+ 
+ 	/// <summary>
+ 	/// Gets the type of navigation that occurred
+ 	/// </summary>
+ 	public NavigationType NavigationType { get; }
+ 
+ 	/// <summary>
+ 	/// Gets the previous navigation item
+ 	/// </summary>
+ 	public T? PreviousItem { get; }
+ 
+ 	/// <summary>
+ 	/// Gets the current navigation item
+ 	/// </summary>
+ 	public T? CurrentItem { get; }
+ }
+ 
+ /// <summary>
+ /// Defines the types of navigation operations
+ /// </summary>
+ public enum NavigationType
+ {
+ 	/// <summary>
+ 	/// Navigation to a new item
+ 	/// </summary>
+ 	NavigateTo,
+ 
+ 	/// <summary>
+ 	/// Navigation backward in the stack
+ 	/// </summary>
+ 	GoBack,
+ 
+ 	/// <summary>
+ 	/// Navigation forward in the stack
+ 	/// </summary>
+ 	GoForward,
+ 
+ 	/// <summary>
+ 	/// The navigation stack was cleared
+ 	/// </summary>
+ 	Clear
+ } 
```

---

Now let me create the models. First, let's create a base navigation item:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using System.Collections.Generic;
+ using System.Collections.ObjectModel;
+ using ktsu.Navigation.Core.Contracts;
+ 
+ namespace ktsu.Navigation.Core.Models;
+ 
+ /// <summary>
+ /// A base implementation of a navigation item
+ /// </summary>
+ public class NavigationItem : INavigationItem
+ {
+ 	private readonly Dictionary<string, object> _metadata;
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="NavigationItem"/> class
+ 	/// </summary>
+ 	/// <param name="id">The unique identifier for this navigation item</param>
+ 	/// <param name="displayName">The display name for this navigation item</param>
+ 	public NavigationItem(string id, string displayName)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(id))
+ 		{
+ 			throw new ArgumentException("Id cannot be null or whitespace.", nameof(id));
+ 		}
+ 
+ 		if (string.IsNullOrWhiteSpace(displayName))
+ 		{
+ 			throw new ArgumentException("Display name cannot be null or whitespace.", nameof(displayName));
+ 		}
+ 
+ 		Id = id;
+ 		DisplayName = displayName;
+ 		CreatedAt = DateTime.UtcNow;
+ 		_metadata = new Dictionary<string, object>();
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public string Id { get; }
+ 
+ 	/// <inheritdoc />
+ 	public string DisplayName { get; set; }
+ 
+ 	/// <inheritdoc />
+ 	public DateTime CreatedAt { get; }
+ 
+ 	/// <inheritdoc />
+ 	public IReadOnlyDictionary<string, object> Metadata => new ReadOnlyDictionary<string, object>(_metadata);
+ 
+ 	/// <inheritdoc />
+ 	public void SetMetadata(string key, object value)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(key))
+ 		{
+ 			throw new ArgumentException("Key cannot be null or whitespace.", nameof(key));
+ 		}
+ 
+ 		ArgumentNullException.ThrowIfNull(value);
+ 
+ 		_metadata[key] = value;
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public bool RemoveMetadata(string key)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(key))
+ 		{
+ 			return false;
+ 		}
+ 
+ 		return _metadata.Remove(key);
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public override string ToString() => DisplayName;
+ 
+ 	/// <inheritdoc />
+ 	public override bool Equals(object? obj)
+ 	{
+ 		if (obj is NavigationItem other)
+ 		{
+ 			return Id.Equals(other.Id, StringComparison.Ordinal);
+ 		}
+ 
+ 		return false;
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public override int GetHashCode() => Id.GetHashCode(StringComparison.Ordinal);
+ } 
```

---

Now let me create the navigation state model:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using System.Collections.Generic;
+ using System.Linq;
+ using ktsu.Navigation.Core.Contracts;
+ 
+ namespace ktsu.Navigation.Core.Models;
+ 
+ /// <summary>
+ /// Represents the state of a navigation stack that can be persisted
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items</typeparam>
+ public class NavigationState<T> : INavigationState<T> where T : INavigationItem
+ {
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="NavigationState{T}"/> class
+ 	/// </summary>
+ 	/// <param name="items">The items in the navigation stack</param>
+ 	/// <param name="currentIndex">The index of the current item</param>
+ 	public NavigationState(IEnumerable<T> items, int currentIndex)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(items);
+ 
+ 		var itemList = items.ToList();
+ 		
+ 		if (currentIndex < -1 || currentIndex >= itemList.Count)
+ 		{
+ 			throw new ArgumentOutOfRangeException(nameof(currentIndex), 
+ 				"Current index must be between -1 and the number of items minus 1.");
+ 		}
+ 
+ 		Items = itemList.AsReadOnly();
+ 		CurrentIndex = currentIndex;
+ 		CreatedAt = DateTime.UtcNow;
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public IReadOnlyList<T> Items { get; }
+ 
+ 	/// <inheritdoc />
+ 	public int CurrentIndex { get; }
+ 
+ 	/// <inheritdoc />
+ 	public DateTime CreatedAt { get; }
+ 
+ 	/// <summary>
+ 	/// Gets the current item in the navigation state
+ 	/// </summary>
+ 	public T? Current => CurrentIndex >= 0 && CurrentIndex < Items.Count ? Items[CurrentIndex] : default;
+ 
+ 	/// <summary>
+ 	/// Creates a new navigation state from a navigation stack
+ 	/// </summary>
+ 	/// <param name="navigationStack">The navigation stack to create state from</param>
+ 	/// <returns>A new navigation state instance</returns>
+ 	public static NavigationState<T> FromNavigationStack(INavigationStack<T> navigationStack)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(navigationStack);
+ 
+ 		var history = navigationStack.GetHistory();
+ 		var current = navigationStack.Current;
+ 		var currentIndex = current != null ? history.ToList().FindIndex(item => item.Id == current.Id) : -1;
+ 
+ 		return new NavigationState<T>(history, currentIndex);
+ 	}
+ } 
```

---

Now let me create the main navigation stack service:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using System.Collections.Generic;
+ using System.Linq;
+ using System.Threading;
+ using System.Threading.Tasks;
+ using ktsu.Navigation.Core.Contracts;
+ using ktsu.Navigation.Core.Models;
+ 
+ namespace ktsu.Navigation.Core.Services;
+ 
+ /// <summary>
+ /// A navigation stack implementation that supports undo/redo and persistence
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items in the stack</typeparam>
+ public class NavigationStack<T> : INavigationStack<T> where T : INavigationItem
+ {
+ 	private readonly List<T> _items;
+ 	private readonly IUndoRedoProvider? _undoRedoProvider;
+ 	private readonly IPersistenceProvider<T>? _persistenceProvider;
+ 	private int _currentIndex;
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="NavigationStack{T}"/> class
+ 	/// </summary>
+ 	/// <param name="undoRedoProvider">Optional undo/redo provider</param>
+ 	/// <param name="persistenceProvider">Optional persistence provider</param>
+ 	public NavigationStack(IUndoRedoProvider? undoRedoProvider = null, IPersistenceProvider<T>? persistenceProvider = null)
+ 	{
+ 		_items = new List<T>();
+ 		_currentIndex = -1;
+ 		_undoRedoProvider = undoRedoProvider;
+ 		_persistenceProvider = persistenceProvider;
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public T? Current => _currentIndex >= 0 && _currentIndex < _items.Count ? _items[_currentIndex] : default;
+ 
+ 	/// <inheritdoc />
+ 	public bool CanGoBack => _currentIndex > 0;
+ 
+ 	/// <inheritdoc />
+ 	public bool CanGoForward => _currentIndex < _items.Count - 1;
+ 
+ 	/// <inheritdoc />
+ 	public int Count => _items.Count;
+ 
+ 	/// <inheritdoc />
+ 	public event NavigationEventHandler<T>? NavigationChanged;
+ 
+ 	/// <inheritdoc />
+ 	public void NavigateTo(T item)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(item);
+ 
+ 		var previousItem = Current;
+ 
+ 		// Create undoable action if undo/redo provider is available
+ 		if (_undoRedoProvider != null)
+ 		{
+ 			var action = new NavigateToAction<T>(this, item, _currentIndex, _items.ToList());
+ 			_undoRedoProvider.RegisterAction(action, $"Navigate to {item.DisplayName}");
+ 		}
+ 
+ 		// Remove any forward history when navigating to a new item
+ 		if (_currentIndex < _items.Count - 1)
+ 		{
+ 			_items.RemoveRange(_currentIndex + 1, _items.Count - _currentIndex - 1);
+ 		}
+ 
+ 		_items.Add(item);
+ 		_currentIndex = _items.Count - 1;
+ 
+ 		OnNavigationChanged(NavigationType.NavigateTo, previousItem, Current);
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public T? GoBack()
+ 	{
+ 		if (!CanGoBack)
+ 		{
+ 			return default;
+ 		}
+ 
+ 		var previousItem = Current;
+ 		_currentIndex--;
+ 
+ 		OnNavigationChanged(NavigationType.GoBack, previousItem, Current);
+ 		return Current;
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public T? GoForward()
+ 	{
+ 		if (!CanGoForward)
+ 		{
+ 			return default;
+ 		}
+ 
+ 		var previousItem = Current;
+ 		_currentIndex++;
+ 
+ 		OnNavigationChanged(NavigationType.GoForward, previousItem, Current);
+ 		return Current;
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public void Clear()
+ 	{
+ 		var previousItem = Current;
+ 		_items.Clear();
+ 		_currentIndex = -1;
+ 
+ 		OnNavigationChanged(NavigationType.Clear, previousItem, null);
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public IReadOnlyList<T> GetHistory() => _items.AsReadOnly();
+ 
+ 	/// <inheritdoc />
+ 	public IReadOnlyList<T> GetBackStack() => _items.Take(_currentIndex).ToList().AsReadOnly();
+ 
+ 	/// <inheritdoc />
+ 	public IReadOnlyList<T> GetForwardStack() => 
+ 		_currentIndex < _items.Count - 1 
+ 			? _items.Skip(_currentIndex + 1).ToList().AsReadOnly() 
+ 			: new List<T>().AsReadOnly();
+ 
+ 	/// <summary>
+ 	/// Saves the current navigation state using the persistence provider
+ 	/// </summary>
+ 	/// <param name="cancellationToken">A cancellation token</param>
+ 	/// <returns>A task representing the asynchronous save operation</returns>
+ 	public async Task SaveStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		if (_persistenceProvider == null)
+ 		{
+ 			return;
+ 		}
+ 
+ 		var state = NavigationState<T>.FromNavigationStack(this);
+ 		await _persistenceProvider.SaveStateAsync(state, cancellationToken);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Loads navigation state using the persistence provider
+ 	/// </summary>
+ 	/// <param name="cancellationToken">A cancellation token</param>
+ 	/// <returns>A task representing the asynchronous load operation</returns>
+ 	public async Task<bool> LoadStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		if (_persistenceProvider == null)
+ 		{
+ 			return false;
+ 		}
+ 
+ 		var state = await _persistenceProvider.LoadStateAsync(cancellationToken);
+ 		if (state == null)
+ 		{
+ 			return false;
+ 		}
+ 
+ 		Clear();
+ 		_items.AddRange(state.Items);
+ 		_currentIndex = state.CurrentIndex;
+ 
+ 		OnNavigationChanged(NavigationType.NavigateTo, null, Current);
+ 		return true;
+ 	}
+ 
+ 	/// <summary>
+ 	/// Restores the navigation stack to a specific state (used by undo/redo operations)
+ 	/// </summary>
+ 	/// <param name="items">The items to restore</param>
+ 	/// <param name="currentIndex">The current index to restore</param>
+ 	internal void RestoreState(IEnumerable<T> items, int currentIndex)
+ 	{
+ 		var previousItem = Current;
+ 		
+ 		_items.Clear();
+ 		_items.AddRange(items);
+ 		_currentIndex = currentIndex;
+ 
+ 		OnNavigationChanged(NavigationType.NavigateTo, previousItem, Current);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Raises the navigation changed event
+ 	/// </summary>
+ 	/// <param name="navigationType">The type of navigation</param>
+ 	/// <param name="previousItem">The previous item</param>
+ 	/// <param name="currentItem">The current item</param>
+ 	protected virtual void OnNavigationChanged(NavigationType navigationType, T? previousItem, T? currentItem)
+ 	{
+ 		NavigationChanged?.Invoke(this, new NavigationEventArgs<T>(navigationType, previousItem, currentItem));
+ 	}
+ } 
```

---

Now I need to create the undo/redo action for navigation:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using System.Collections.Generic;
+ using System.Linq;
+ using ktsu.Navigation.Core.Contracts;
+ 
+ namespace ktsu.Navigation.Core.Services;
+ 
+ /// <summary>
+ /// An undoable action for navigation operations
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items</typeparam>
+ internal class NavigateToAction<T> : IUndoableAction where T : INavigationItem
+ {
+ 	private readonly NavigationStack<T> _navigationStack;
+ 	private readonly T _newItem;
+ 	private readonly int _previousIndex;
+ 	private readonly List<T> _previousItems;
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="NavigateToAction{T}"/> class
+ 	/// </summary>
+ 	/// <param name="navigationStack">The navigation stack</param>
+ 	/// <param name="newItem">The new item to navigate to</param>
+ 	/// <param name="previousIndex">The previous current index</param>
+ 	/// <param name="previousItems">The previous items in the stack</param>
+ 	public NavigateToAction(NavigationStack<T> navigationStack, T newItem, int previousIndex, List<T> previousItems)
+ 	{
+ 		_navigationStack = navigationStack ?? throw new ArgumentNullException(nameof(navigationStack));
+ 		_newItem = newItem ?? throw new ArgumentNullException(nameof(newItem));
+ 		_previousIndex = previousIndex;
+ 		_previousItems = previousItems?.ToList() ?? throw new ArgumentNullException(nameof(previousItems));
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public string Description => $"Navigate to {_newItem.DisplayName}";
+ 
+ 	/// <inheritdoc />
+ 	public void Execute()
+ 	{
+ 		// The action is already executed when it's created, so this is a no-op
+ 		// or could be used to re-execute the navigation if needed
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public void Undo()
+ 	{
+ 		_navigationStack.RestoreState(_previousItems, _previousIndex);
+ 	}
+ } 
```

---

Now let me create some built-in persistence providers. First, a simple in-memory provider:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System.Threading;
+ using System.Threading.Tasks;
+ using ktsu.Navigation.Core.Contracts;
+ 
+ namespace ktsu.Navigation.Core.Services;
+ 
+ /// <summary>
+ /// An in-memory persistence provider for testing and simple scenarios
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items</typeparam>
+ public class InMemoryPersistenceProvider<T> : IPersistenceProvider<T> where T : INavigationItem
+ {
+ 	private INavigationState<T>? _savedState;
+ 
+ 	/// <inheritdoc />
+ 	public Task SaveStateAsync(INavigationState<T> state, CancellationToken cancellationToken = default)
+ 	{
+ 		_savedState = state;
+ 		return Task.CompletedTask;
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public Task<INavigationState<T>?> LoadStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		return Task.FromResult(_savedState);
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public Task<bool> HasSavedStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		return Task.FromResult(_savedState != null);
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public Task ClearSavedStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		_savedState = null;
+ 		return Task.CompletedTask;
+ 	}
+ } 
```

---

Now let me create a JSON file-based persistence provider:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using System.IO;
+ using System.Text.Json;
+ using System.Threading;
+ using System.Threading.Tasks;
+ using ktsu.Navigation.Core.Contracts;
+ 
+ namespace ktsu.Navigation.Core.Services;
+ 
+ /// <summary>
+ /// A JSON file-based persistence provider for navigation state
+ /// </summary>
+ /// <typeparam name="T">The type of navigation items</typeparam>
+ public class JsonFilePersistenceProvider<T> : IPersistenceProvider<T> where T : INavigationItem
+ {
+ 	private readonly string _filePath;
+ 	private readonly JsonSerializerOptions _jsonOptions;
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="JsonFilePersistenceProvider{T}"/> class
+ 	/// </summary>
+ 	/// <param name="filePath">The file path to store the navigation state</param>
+ 	/// <param name="jsonOptions">Optional JSON serializer options</param>
+ 	public JsonFilePersistenceProvider(string filePath, JsonSerializerOptions? jsonOptions = null)
+ 	{
+ 		if (string.IsNullOrWhiteSpace(filePath))
+ 		{
+ 			throw new ArgumentException("File path cannot be null or whitespace.", nameof(filePath));
+ 		}
+ 
+ 		_filePath = filePath;
+ 		_jsonOptions = jsonOptions ?? new JsonSerializerOptions
+ 		{
+ 			WriteIndented = true,
+ 			PropertyNamingPolicy = JsonNamingPolicy.CamelCase
+ 		};
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public async Task SaveStateAsync(INavigationState<T> state, CancellationToken cancellationToken = default)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(state);
+ 
+ 		var directory = Path.GetDirectoryName(_filePath);
+ 		if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
+ 		{
+ 			Directory.CreateDirectory(directory);
+ 		}
+ 
+ 		var json = JsonSerializer.Serialize(state, _jsonOptions);
+ 		await File.WriteAllTextAsync(_filePath, json, cancellationToken);
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public async Task<INavigationState<T>?> LoadStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		if (!File.Exists(_filePath))
+ 		{
+ 			return null;
+ 		}
+ 
+ 		try
+ 		{
+ 			var json = await File.ReadAllTextAsync(_filePath, cancellationToken);
+ 			return JsonSerializer.Deserialize<INavigationState<T>>(json, _jsonOptions);
+ 		}
+ 		catch (JsonException)
+ 		{
+ 			// If deserialization fails, return null
+ 			return null;
+ 		}
+ 		catch (IOException)
+ 		{
+ 			// If file read fails, return null
+ 			return null;
+ 		}
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public Task<bool> HasSavedStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		return Task.FromResult(File.Exists(_filePath));
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public Task ClearSavedStateAsync(CancellationToken cancellationToken = default)
+ 	{
+ 		if (File.Exists(_filePath))
+ 		{
+ 			File.Delete(_filePath);
+ 		}
+ 
+ 		return Task.CompletedTask;
+ 	}
+ } 
```

---

Now let me create a simple undo/redo provider implementation:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using System.Collections.Generic;
+ using System.Linq;
+ using ktsu.Navigation.Core.Contracts;
+ 
+ namespace ktsu.Navigation.Core.Services;
+ 
+ /// <summary>
+ /// A simple implementation of an undo/redo provider
+ /// </summary>
+ public class SimpleUndoRedoProvider : IUndoRedoProvider
+ {
+ 	private readonly List<IUndoableAction> _undoStack;
+ 	private readonly List<IUndoableAction> _redoStack;
+ 	private readonly int _maxHistorySize;
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="SimpleUndoRedoProvider"/> class
+ 	/// </summary>
+ 	/// <param name="maxHistorySize">The maximum number of actions to keep in history</param>
+ 	public SimpleUndoRedoProvider(int maxHistorySize = 100)
+ 	{
+ 		if (maxHistorySize <= 0)
+ 		{
+ 			throw new ArgumentException("Max history size must be greater than zero.", nameof(maxHistorySize));
+ 		}
+ 
+ 		_maxHistorySize = maxHistorySize;
+ 		_undoStack = new List<IUndoableAction>();
+ 		_redoStack = new List<IUndoableAction>();
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public bool CanUndo => _undoStack.Count > 0;
+ 
+ 	/// <inheritdoc />
+ 	public bool CanRedo => _redoStack.Count > 0;
+ 
+ 	/// <inheritdoc />
+ 	public event EventHandler? StateChanged;
+ 
+ 	/// <inheritdoc />
+ 	public void RegisterAction(IUndoableAction action, string description)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(action);
+ 
+ 		// Add to undo stack
+ 		_undoStack.Add(action);
+ 
+ 		// Clear redo stack when new action is registered
+ 		_redoStack.Clear();
+ 
+ 		// Trim undo stack if it exceeds max size
+ 		if (_undoStack.Count > _maxHistorySize)
+ 		{
+ 			_undoStack.RemoveAt(0);
+ 		}
+ 
+ 		OnStateChanged();
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public bool Undo()
+ 	{
+ 		if (!CanUndo)
+ 		{
+ 			return false;
+ 		}
+ 
+ 		var action = _undoStack.Last();
+ 		_undoStack.RemoveAt(_undoStack.Count - 1);
+ 
+ 		try
+ 		{
+ 			action.Undo();
+ 			_redoStack.Add(action);
+ 			OnStateChanged();
+ 			return true;
+ 		}
+ 		catch
+ 		{
+ 			// If undo fails, put the action back on the undo stack
+ 			_undoStack.Add(action);
+ 			throw;
+ 		}
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public bool Redo()
+ 	{
+ 		if (!CanRedo)
+ 		{
+ 			return false;
+ 		}
+ 
+ 		var action = _redoStack.Last();
+ 		_redoStack.RemoveAt(_redoStack.Count - 1);
+ 
+ 		try
+ 		{
+ 			action.Execute();
+ 			_undoStack.Add(action);
+ 			OnStateChanged();
+ 			return true;
+ 		}
+ 		catch
+ 		{
+ 			// If redo fails, put the action back on the redo stack
+ 			_redoStack.Add(action);
+ 			throw;
+ 		}
+ 	}
+ 
+ 	/// <inheritdoc />
+ 	public void Clear()
+ 	{
+ 		_undoStack.Clear();
+ 		_redoStack.Clear();
+ 		OnStateChanged();
+ 	}
+ 
+ 	/// <summary>
+ 	/// Gets the current undo stack for debugging or inspection
+ 	/// </summary>
+ 	/// <returns>A read-only list of undoable actions</returns>
+ 	public IReadOnlyList<IUndoableAction> GetUndoStack() => _undoStack.AsReadOnly();
+ 
+ 	/// <summary>
+ 	/// Gets the current redo stack for debugging or inspection
+ 	/// </summary>
+ 	/// <returns>A read-only list of undoable actions</returns>
+ 	public IReadOnlyList<IUndoableAction> GetRedoStack() => _redoStack.AsReadOnly();
+ 
+ 	/// <summary>
+ 	/// Raises the state changed event
+ 	/// </summary>
+ 	protected virtual void OnStateChanged()
+ 	{
+ 		StateChanged?.Invoke(this, EventArgs.Empty);
+ 	}
+ } 
```

---

Now let me create a factory for building navigation stacks with dependency injection support:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using ktsu.Navigation.Core.Contracts;
+ 
+ namespace ktsu.Navigation.Core.Services;
+ 
+ /// <summary>
+ /// A factory for creating navigation stacks with configured providers
+ /// </summary>
+ public class NavigationStackFactory
+ {
+ 	private readonly IUndoRedoProvider? _defaultUndoRedoProvider;
+ 	private readonly Func<Type, object?>? _serviceProvider;
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="NavigationStackFactory"/> class
+ 	/// </summary>
+ 	/// <param name="defaultUndoRedoProvider">Default undo/redo provider to use</param>
+ 	/// <param name="serviceProvider">Optional service provider for dependency injection</param>
+ 	public NavigationStackFactory(IUndoRedoProvider? defaultUndoRedoProvider = null, Func<Type, object?>? serviceProvider = null)
+ 	{
+ 		_defaultUndoRedoProvider = defaultUndoRedoProvider;
+ 		_serviceProvider = serviceProvider;
+ 	}
+ 
+ 	/// <summary>
+ 	/// Creates a new navigation stack with the default providers
+ 	/// </summary>
+ 	/// <typeparam name="T">The type of navigation items</typeparam>
+ 	/// <returns>A new navigation stack instance</returns>
+ 	public INavigationStack<T> CreateNavigationStack<T>() where T : INavigationItem
+ 	{
+ 		var persistenceProvider = _serviceProvider?.Invoke(typeof(IPersistenceProvider<T>)) as IPersistenceProvider<T>;
+ 		var undoRedoProvider = _serviceProvider?.Invoke(typeof(IUndoRedoProvider)) as IUndoRedoProvider ?? _defaultUndoRedoProvider;
+ 
+ 		return new NavigationStack<T>(undoRedoProvider, persistenceProvider);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Creates a new navigation stack with specific providers
+ 	/// </summary>
+ 	/// <typeparam name="T">The type of navigation items</typeparam>
+ 	/// <param name="undoRedoProvider">The undo/redo provider to use</param>
+ 	/// <param name="persistenceProvider">The persistence provider to use</param>
+ 	/// <returns>A new navigation stack instance</returns>
+ 	public INavigationStack<T> CreateNavigationStack<T>(IUndoRedoProvider? undoRedoProvider, IPersistenceProvider<T>? persistenceProvider) where T : INavigationItem
+ 	{
+ 		return new NavigationStack<T>(undoRedoProvider, persistenceProvider);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Creates a new navigation stack with only an undo/redo provider
+ 	/// </summary>
+ 	/// <typeparam name="T">The type of navigation items</typeparam>
+ 	/// <param name="undoRedoProvider">The undo/redo provider to use</param>
+ 	/// <returns>A new navigation stack instance</returns>
+ 	public INavigationStack<T> CreateNavigationStack<T>(IUndoRedoProvider undoRedoProvider) where T : INavigationItem
+ 	{
+ 		return new NavigationStack<T>(undoRedoProvider);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Creates a new navigation stack with only a persistence provider
+ 	/// </summary>
+ 	/// <typeparam name="T">The type of navigation items</typeparam>
+ 	/// <param name="persistenceProvider">The persistence provider to use</param>
+ 	/// <returns>A new navigation stack instance</returns>
+ 	public INavigationStack<T> CreateNavigationStack<T>(IPersistenceProvider<T> persistenceProvider) where T : INavigationItem
+ 	{
+ 		return new NavigationStack<T>(_defaultUndoRedoProvider, persistenceProvider);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Creates a basic navigation stack without any providers
+ 	/// </summary>
+ 	/// <typeparam name="T">The type of navigation items</typeparam>
+ 	/// <returns>A new navigation stack instance</returns>
+ 	public INavigationStack<T> CreateBasicNavigationStack<T>() where T : INavigationItem
+ 	{
+ 		return new NavigationStack<T>();
+ 	}
+ } 
```

---

Now let me update the test project to create comprehensive tests:

---

Removing the sample test file to create proper navigation tests

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ using System;
+ using System.Linq;
+ using Microsoft.VisualStudio.TestTools.UnitTesting;
+ using ktsu.Navigation.Core.Contracts;
+ using ktsu.Navigation.Core.Models;
+ using ktsu.Navigation.Core.Services;
+ 
+ namespace ktsu.Navigation.Test;
+ 
+ [TestClass]
+ public class NavigationStackTests
+ {
+ 	private INavigationStack<NavigationItem>? _navigationStack;
+ 	private SimpleUndoRedoProvider? _undoRedoProvider;
+ 	private InMemoryPersistenceProvider<NavigationItem>? _persistenceProvider;
+ 
+ 	[TestInitialize]
+ 	public void Setup()
+ 	{
+ 		_undoRedoProvider = new SimpleUndoRedoProvider();
+ 		_persistenceProvider = new InMemoryPersistenceProvider<NavigationItem>();
+ 		_navigationStack = new NavigationStack<NavigationItem>(_undoRedoProvider, _persistenceProvider);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NavigationStack_InitialState_IsEmpty()
+ 	{
+ 		// Arrange & Act
+ 		// Setup already creates the navigation stack
+ 
+ 		// Assert
+ 		Assert.IsNull(_navigationStack!.Current);
+ 		Assert.IsFalse(_navigationStack.CanGoBack);
+ 		Assert.IsFalse(_navigationStack.CanGoForward);
+ 		Assert.AreEqual(0, _navigationStack.Count);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NavigateTo_SingleItem_SetsCurrent()
+ 	{
+ 		// Arrange
+ 		var item = new NavigationItem("1", "First Item");
+ 
+ 		// Act
+ 		_navigationStack!.NavigateTo(item);
+ 
+ 		// Assert
+ 		Assert.AreEqual(item, _navigationStack.Current);
+ 		Assert.IsFalse(_navigationStack.CanGoBack);
+ 		Assert.IsFalse(_navigationStack.CanGoForward);
+ 		Assert.AreEqual(1, _navigationStack.Count);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NavigateTo_MultipleItems_AllowsBackNavigation()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 
+ 		// Act
+ 		_navigationStack!.NavigateTo(item1);
+ 		_navigationStack.NavigateTo(item2);
+ 
+ 		// Assert
+ 		Assert.AreEqual(item2, _navigationStack.Current);
+ 		Assert.IsTrue(_navigationStack.CanGoBack);
+ 		Assert.IsFalse(_navigationStack.CanGoForward);
+ 		Assert.AreEqual(2, _navigationStack.Count);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void GoBack_WithHistory_NavigatesToPrevious()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 		_navigationStack!.NavigateTo(item1);
+ 		_navigationStack.NavigateTo(item2);
+ 
+ 		// Act
+ 		var result = _navigationStack.GoBack();
+ 
+ 		// Assert
+ 		Assert.AreEqual(item1, result);
+ 		Assert.AreEqual(item1, _navigationStack.Current);
+ 		Assert.IsFalse(_navigationStack.CanGoBack);
+ 		Assert.IsTrue(_navigationStack.CanGoForward);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void GoForward_WithForwardHistory_NavigatesToNext()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 		_navigationStack!.NavigateTo(item1);
+ 		_navigationStack.NavigateTo(item2);
+ 		_navigationStack.GoBack();
+ 
+ 		// Act
+ 		var result = _navigationStack.GoForward();
+ 
+ 		// Assert
+ 		Assert.AreEqual(item2, result);
+ 		Assert.AreEqual(item2, _navigationStack.Current);
+ 		Assert.IsTrue(_navigationStack.CanGoBack);
+ 		Assert.IsFalse(_navigationStack.CanGoForward);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NavigateTo_ClearsForwardHistory()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 		var item3 = new NavigationItem("3", "Third Item");
+ 		_navigationStack!.NavigateTo(item1);
+ 		_navigationStack.NavigateTo(item2);
+ 		_navigationStack.GoBack();
+ 
+ 		// Act
+ 		_navigationStack.NavigateTo(item3);
+ 
+ 		// Assert
+ 		Assert.AreEqual(item3, _navigationStack.Current);
+ 		Assert.IsTrue(_navigationStack.CanGoBack);
+ 		Assert.IsFalse(_navigationStack.CanGoForward);
+ 		Assert.AreEqual(2, _navigationStack.Count);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void Clear_RemovesAllItems()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 		_navigationStack!.NavigateTo(item1);
+ 		_navigationStack.NavigateTo(item2);
+ 
+ 		// Act
+ 		_navigationStack.Clear();
+ 
+ 		// Assert
+ 		Assert.IsNull(_navigationStack.Current);
+ 		Assert.IsFalse(_navigationStack.CanGoBack);
+ 		Assert.IsFalse(_navigationStack.CanGoForward);
+ 		Assert.AreEqual(0, _navigationStack.Count);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void NavigationChanged_RaisedOnNavigation()
+ 	{
+ 		// Arrange
+ 		var eventRaised = false;
+ 		NavigationEventArgs<NavigationItem>? eventArgs = null;
+ 		_navigationStack!.NavigationChanged += (sender, e) =>
+ 		{
+ 			eventRaised = true;
+ 			eventArgs = e;
+ 		};
+ 		var item = new NavigationItem("1", "First Item");
+ 
+ 		// Act
+ 		_navigationStack.NavigateTo(item);
+ 
+ 		// Assert
+ 		Assert.IsTrue(eventRaised);
+ 		Assert.IsNotNull(eventArgs);
+ 		Assert.AreEqual(NavigationType.NavigateTo, eventArgs.NavigationType);
+ 		Assert.IsNull(eventArgs.PreviousItem);
+ 		Assert.AreEqual(item, eventArgs.CurrentItem);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void UndoRedo_WithUndoRedoProvider_WorksCorrectly()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 		_navigationStack!.NavigateTo(item1);
+ 
+ 		// Act
+ 		_navigationStack.NavigateTo(item2);
+ 		_undoRedoProvider!.Undo();
+ 
+ 		// Assert
+ 		Assert.AreEqual(item1, _navigationStack.Current);
+ 		Assert.IsTrue(_undoRedoProvider.CanRedo);
+ 
+ 		// Act - Redo
+ 		_undoRedoProvider.Redo();
+ 
+ 		// Assert
+ 		Assert.AreEqual(item2, _navigationStack.Current);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void GetBackStack_ReturnsCorrectItems()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 		var item3 = new NavigationItem("3", "Third Item");
+ 		_navigationStack!.NavigateTo(item1);
+ 		_navigationStack.NavigateTo(item2);
+ 		_navigationStack.NavigateTo(item3);
+ 
+ 		// Act
+ 		var backStack = _navigationStack.GetBackStack();
+ 
+ 		// Assert
+ 		Assert.AreEqual(2, backStack.Count);
+ 		Assert.AreEqual(item1, backStack[0]);
+ 		Assert.AreEqual(item2, backStack[1]);
+ 	}
+ 
+ 	[TestMethod]
+ 	public void GetForwardStack_ReturnsCorrectItems()
+ 	{
+ 		// Arrange
+ 		var item1 = new NavigationItem("1", "First Item");
+ 		var item2 = new NavigationItem("2", "Second Item");
+ 		var item3 = new NavigationItem("3", "Third Item");
+ 		_navigationStack!.NavigateTo(item1);
+ 		_navigationStack.NavigateTo(item2);
+ 		_navigationStack.NavigateTo(item3);
+ 		_navigationStack.GoBack();
+ 		_navigationStack.GoBack();
+ 
+ 		// Act
+ 		var forwardStack = _navigationStack.GetForwardStack();
+ 
+ 		// Assert
+ 		Assert.AreEqual(2, forwardStack.Count);
+ 		Assert.AreEqual(item2, forwardStack[0]);
+ 		Assert.AreEqual(item3, forwardStack[1]);
+ 	}
+ } 
```

---





---

_**User**_

make a docs directory with design documentation for the library

---

_**Assistant**_



---

I'll create a comprehensive docs directory with design documentation for the navigation library. Let me start by creating the directory structure and documentation files.

---

```diff
- 
+ # Navigation Stack Library Documentation
+ 
+ A comprehensive .NET library for managing navigation state with undo/redo support and persistence capabilities.
+ 
+ ## Overview
+ 
+ The Navigation Stack Library provides a robust, extensible solution for managing navigation within applications. It follows SOLID principles and implements a clean Contracts, Models, Services (CMS) architecture.
+ 
+ ## Key Features
+ 
+ - **Navigation Stack Management**: Navigate forward, backward, and maintain history
+ - **Undo/Redo Integration**: Seamless integration with external undo/redo providers
+ - **Persistence Support**: Save and restore navigation state across sessions
+ - **Event-Driven Architecture**: React to navigation changes with comprehensive events
+ - **Extensible Design**: Plugin architecture for custom persistence and undo/redo providers
+ - **Type Safety**: Strongly typed navigation items with metadata support
+ 
+ ## Quick Start
+ 
+ ```csharp
+ using ktsu.Navigation.Core.Contracts;
+ using ktsu.Navigation.Core.Models;
+ using ktsu.Navigation.Core.Services;
+ 
+ // Create a navigation stack
+ var navigationStack = new NavigationStack<NavigationItem>();
+ 
+ // Create navigation items
+ var homeItem = new NavigationItem("home", "Home Page");
+ var aboutItem = new NavigationItem("about", "About Page");
+ 
+ // Navigate
+ navigationStack.NavigateTo(homeItem);
+ navigationStack.NavigateTo(aboutItem);
+ 
+ // Go back
+ var previous = navigationStack.GoBack(); // Returns to Home Page
+ 
+ // Check navigation state
+ Console.WriteLine($"Can go back: {navigationStack.CanGoBack}");
+ Console.WriteLine($"Can go forward: {navigationStack.CanGoForward}");
+ Console.WriteLine($"Current: {navigationStack.Current?.DisplayName}");
+ ```
+ 
+ ## Documentation Structure
+ 
+ - **[Architecture](Architecture.md)** - Detailed architecture and design patterns
+ - **[API Reference](API.md)** - Complete API documentation
+ - **[Usage Guide](Usage.md)** - Common usage patterns and best practices
+ - **[Integration Guide](Integration.md)** - How to integrate with external systems
+ - **[Examples](Examples.md)** - Comprehensive code examples
+ - **[Design Decisions](Design-Decisions.md)** - Rationale behind architectural choices
+ 
+ ## Installation
+ 
+ ```xml
+ <PackageReference Include="ktsu.Navigation.Core" Version="1.0.0" />
+ ```
+ 
+ ## Requirements
+ 
+ - .NET 8.0 or later
+ - Compatible with all .NET platforms (Framework, Core, Standard)
+ 
+ ## Contributing
+ 
+ Please read our contributing guidelines and follow the established coding standards.
+ 
+ ## License
+ 
+ Licensed under the MIT License. See LICENSE.md for details. 
```

---



---



---

